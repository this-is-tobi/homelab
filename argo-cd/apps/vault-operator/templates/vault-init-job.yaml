{{- if and .Values.vault.enabled .Values.vault.initSecrets.enabled }}
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: vault-init-secrets
  namespace: {{ .Release.Namespace }}
  annotations:
    argocd.argoproj.io/hook: PreSync
    argocd.argoproj.io/hook-weight: "-5"
    argocd.argoproj.io/sync-wave: "-1"

---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: vault-init-secrets
  namespace: {{ .Release.Namespace }}
  annotations:
    argocd.argoproj.io/hook: PreSync
    argocd.argoproj.io/hook-weight: "-5"
    argocd.argoproj.io/sync-wave: "-1"
rules:
- apiGroups: [""]
  resources: ["serviceaccounts/token"]
  resourceNames: ["vault-init-secrets"]
  verbs: ["create"]

---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: vault-init-secrets
  namespace: {{ .Release.Namespace }}
  annotations:
    argocd.argoproj.io/hook: PreSync
    argocd.argoproj.io/hook-weight: "-5"
    argocd.argoproj.io/sync-wave: "-1"
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: vault-init-secrets
subjects:
- kind: ServiceAccount
  name: vault-init-secrets
  namespace: {{ .Release.Namespace }}

---
apiVersion: batch/v1
kind: Job
metadata:
  name: vault-init-secrets-{{ .Release.Revision | default "1" }}
  namespace: {{ .Release.Namespace }}
  annotations:
    argocd.argoproj.io/hook: PostSync
    argocd.argoproj.io/hook-weight: "10"
    argocd.argoproj.io/hook-delete-policy: BeforeHookCreation
    argocd.argoproj.io/sync-wave: "10"
  labels:
    app.kubernetes.io/name: vault-init-secrets
    app.kubernetes.io/instance: {{ .Release.Name }}
    app.kubernetes.io/managed-by: {{ .Release.Service }}
spec:
  backoffLimit: {{ .Values.vault.initSecrets.backoffLimit | default 3 }}
  ttlSecondsAfterFinished: {{ .Values.vault.initSecrets.ttlSecondsAfterFinished | default 86400 }}
  template:
    metadata:
      labels:
        app.kubernetes.io/name: vault-init-secrets
        app.kubernetes.io/instance: {{ .Release.Name }}
    spec:
      serviceAccountName: vault-init-secrets
      restartPolicy: Never
      {{- if .Values.vault.initSecrets.nodeSelector }}
      nodeSelector:
        {{- toYaml .Values.vault.initSecrets.nodeSelector | nindent 8 }}
      {{- end }}
      {{- if .Values.vault.initSecrets.tolerations }}
      tolerations:
        {{- toYaml .Values.vault.initSecrets.tolerations | nindent 8 }}
      {{- end }}
      initContainers:
      - name: wait-for-vault
        image: {{ .Values.vault.initSecrets.image | default "docker.io/curlimages/curl:8.5.0" }}
        command:
        - /bin/sh
        - -c
        - |
          set -e
          echo "Waiting for Vault to be ready..."
          max_attempts=60
          attempt=0

          while [ $attempt -lt $max_attempts ]; do
            if curl -k -s {{ .Values.vault.initSecrets.vaultAddr | default (printf "https://%s.%s.svc.cluster.local:8200" .Values.vault.name .Release.Namespace) }}/v1/sys/health | grep -q "initialized"; then
              echo "Vault is ready!"
              exit 0
            fi
            echo "Waiting for Vault... (attempt $((attempt+1))/$max_attempts)"
            sleep 5
            attempt=$((attempt+1))
          done

          echo "Timeout waiting for Vault to become ready"
          exit 1
        resources:
          requests:
            cpu: 10m
            memory: 16Mi
          limits:
            cpu: 50m
            memory: 32Mi
      containers:
      - name: init-secrets
        image: {{ .Values.vault.initSecrets.image | default "ghcr.io/this-is-tobi/tools/backup:latest" }}
        env:
        - name: VAULT_ADDR
          value: {{ .Values.vault.initSecrets.vaultAddr | default (printf "https://%s.%s.svc.cluster.local:8200" .Values.vault.name .Release.Namespace) | quote }}
        - name: VAULT_SKIP_VERIFY
          value: {{ .Values.vault.initSecrets.skipTLSVerify | default "true" | quote }}
        command:
        - /bin/sh
        - -c
        - |
          set -e

          echo "=================================================="
          echo "Vault Secret Initialization Job"
          echo "=================================================="
          echo "Vault Address: $VAULT_ADDR"
          echo "Namespace: {{ .Release.Namespace }}"
          echo ""

          # Verify dependencies
          echo "Checking dependencies..."
          echo "  - Vault: $(vault version 2>&1 | head -1)"
          echo "  - jq: $(jq --version)"
          echo ""

          # Authenticate to Vault using Kubernetes auth
          echo "Authenticating to Vault..."

          # Get Kubernetes service account token
          KUBE_TOKEN="$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)"

          # Login to Vault
          VAULT_TOKEN="$(vault write -field=token auth/kubernetes/login \
            role={{ .Values.vault.initSecrets.vaultRole | default "vault-init-secrets" }} \
            jwt="$KUBE_TOKEN")"

          if [ -z "$VAULT_TOKEN" ]; then
            echo "ERROR: Failed to authenticate to Vault"
            exit 1
          fi

          export VAULT_TOKEN
          echo "✓ Successfully authenticated to Vault"
          echo ""

          # Function to generate random string
          generate_random() {
            length=$1
            tr -dc 'A-Za-z0-9' </dev/urandom | head -c "$length"
          }

          # Function to check if secret exists
          secret_exists() {
            path=$1
            vault kv get "$path" >/dev/null 2>&1
          }

          # Function to replace template values with actual generated values
          generate_values() {
            template_json=$1

            # Process the template and generate actual values using jq (compact output)
            result=$(echo "$template_json" | jq -c '
              def generate_value:
                if type == "object" then
                  if has("type") then
                    # This is a value template - generate actual value
                    if .type == "random" then
                      # Generate random value inline
                      (.length // 32) as $len |
                      env.RANDOM_SEED as $seed |
                      "__RANDOM_" + ($len | tostring) + "__"
                    elif .type == "uuid" then
                      "__UUID__"
                    elif .type == "age" then
                      # Generate age key pair
                      if .field == "secret" then
                        "__AGE_SECRET__"
                      elif .field == "public" then
                        "__AGE_PUBLIC__"
                      else
                        "__AGE_SECRET__"
                      end
                    elif .type == "static" then
                      .value
                    else
                      .value
                    end
                  else
                    # Nested object - recurse
                    map_values(generate_value)
                  end
                else
                  .
                end;
              generate_value
            ')

            # Replace all RANDOM placeholders (each gets unique value)
            while echo "$result" | grep -q '__RANDOM_[0-9]\+__'; do
              # Extract length from placeholder
              placeholder=$(echo "$result" | grep -o '__RANDOM_[0-9]\+__' | head -1)
              length=$(echo "$placeholder" | sed 's/__RANDOM_\([0-9]\+\)__/\1/')
              random_val=$(generate_random "$length")
              # Replace only the first occurrence
              result=$(echo "$result" | sed "s/${placeholder}/${random_val}/")
            done

            # Replace all UUID placeholders (each gets unique value)
            while echo "$result" | grep -q '__UUID__'; do
              uuid_val=$(cat /proc/sys/kernel/random/uuid)
              result=$(echo "$result" | sed "s/__UUID__/${uuid_val}/")
            done

            # Replace all AGE key placeholders (generate once, extract both secret and public)
            if echo "$result" | grep -q '__AGE_'; then
              # Generate age key pair once
              age_output=$(age-keygen 2>&1)
              age_secret=$(echo "$age_output" | grep '^AGE-SECRET-KEY-' | tr -d '\n')
              age_public=$(echo "$age_output" | grep '^# public key:' | sed 's/^# public key: //')

              # Replace all AGE placeholders
              result=$(echo "$result" | sed "s/__AGE_SECRET__/${age_secret}/g")
              result=$(echo "$result" | sed "s/__AGE_PUBLIC__/${age_public}/g")
            fi

            echo "$result"
          }

          # Function to create or update secret with nested JSON support
          init_secret() {
            path=$1
            template_data=$2

            echo "Processing secret: $path"

            # Validate template data is valid JSON
            if ! echo "$template_data" | jq empty 2>/dev/null; then
              echo "  ERROR: Invalid JSON template data"
              echo "$template_data"
              return 1
            fi

            # Generate actual values from template
            new_data_json=$(generate_values "$template_data")

            # Validate generated JSON
            if ! echo "$new_data_json" | jq empty 2>/dev/null; then
              echo "  ERROR: Failed to generate valid JSON"
              echo "$new_data_json"
              return 1
            fi

            # Check if secret exists
            if secret_exists "$path"; then
              echo "  Secret exists, merging with new data..."

              # Read existing secret
              existing_data=$(vault kv get -format=json "$path" | jq '.data.data')

              # Deep merge: existing values take precedence (preserved)
              # Only add new keys/nested paths that don't exist
              merged_data=$(echo "$existing_data" "$new_data_json" | jq -s '
                def deep_merge:
                  .[0] as $existing | .[1] as $new |
                  if ($existing | type) == "object" and ($new | type) == "object" then
                    ($existing + $new) | to_entries | reduce .[] as $item (
                      {};
                      . + {
                        ($item.key): (
                          if $existing | has($item.key) then
                            if ($existing[$item.key] | type) == "object" and ($item.value | type) == "object" then
                              [$existing[$item.key], $item.value] | deep_merge
                            else
                              $existing[$item.key]  # Preserve existing value
                            end
                          else
                            $item.value  # Add new value
                          end
                        )
                      }
                    )
                  else
                    $existing  # Preserve existing if not both objects
                  end;

                deep_merge
              ')

              # Check if anything changed
              if [ "$existing_data" = "$merged_data" ]; then
                echo "  ✓ All keys present, no update needed"
              else
                # Show what's being added (simplified diff)
                added_count=$(echo "$existing_data" "$merged_data" | jq -s '
                  def count_leaves:
                    if type == "object" then
                      [.[] | count_leaves] | add
                    else
                      1
                    end;

                  (.[1] | count_leaves) - (.[0] | count_leaves)
                ')

                if [ "$added_count" -gt 0 ]; then
                  echo "  + Adding $added_count new key(s)"
                fi

                # Update secret with merged data using vault CLI with stdin
                if ! echo "$merged_data" | vault kv put "$path" - 2>&1; then
                  echo "  ERROR: Failed to update secret"
                  return 1
                fi
                echo "  ✓ Secret updated"
              fi
            else
              echo "  + Creating new secret"
              # Write secret using vault CLI with stdin (preserves nested JSON)
              if ! echo "$new_data_json" | vault kv put "$path" - 2>&1; then
                echo "  ERROR: Failed to create secret"
                return 1
              fi
              echo "  ✓ Secret created"
            fi
            echo ""
          }

          echo "=================================================="
          echo "Initializing Secrets"
          echo "=================================================="
          echo ""

          {{- range .Values.vault.initSecrets.secrets }}
          # Initialize: {{ .path }}
          cat <<'SECRET_DATA_EOF' | init_secret "{{ .path }}" "$(cat)"
          {{- .data | toJson | nindent 10 }}
          SECRET_DATA_EOF

          {{- end }}

          echo "=================================================="
          echo "Secret Initialization Complete"
          echo "=================================================="
          echo ""
          echo "Summary:"
          {{- range .Values.vault.initSecrets.secrets }}
          echo "  - {{ .path }}"
          {{- end }}
          echo ""
          echo "Note: Existing secrets and keys were preserved."
          echo "Only missing secrets/keys were created."
        resources:
          {{- toYaml .Values.vault.initSecrets.resources | nindent 10 }}
        securityContext:
          allowPrivilegeEscalation: false
          readOnlyRootFilesystem: true
          runAsNonRoot: true
          runAsUser: 100
          capabilities:
            drop:
            - ALL
          seccompProfile:
            type: RuntimeDefault
{{- end }}
